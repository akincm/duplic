#!/usr/bin/python
import os, sys
import getopt
import hashlib
import filecmp
import time

"""
Duplicates checker
This program searches through subdirectories and returns a list of all same files separated by a semicolon ";".
"""
cepoch = int(time.time())
#Detect os Type
tot_red_size ,ostype, osep, path = (0, None, None, None)

if (os.name == "nt"):
    ostype = "win"
    osep = "\\"
    path = "C:\\Users\\"

elif (os.name == "posix"):
    ostype = "posix"
    osep = "/"
    path = "/home/"
else:
    print("Unsupported OS.")
    sys.exit()


if len(sys.argv) == 1:
        print("No arguments specified\nUse `duplic -h` for help")
        sys.exit()

VERSION = "0.71"
argv = sys.argv[1:]
opts, args = getopt.getopt(argv, 'm:h', ['method', 'help', 'version'])

dir_data = [] #Will contain a list of all file paths
ls_data = {} #Will contain a key value pair of directory path and a string of all files inside

def iterate_dirs(root="null",data=dir_data,ls_bol = False):
    """Appends a dictionary with a key value pair of filename and filehash from all the files in the directory and subdirectories."""
    if root == "null":
        if ostype == "posix":
            if relative_directory[0] == "/":
                root = relative_directory + "/"
            else:
                root = os.getcwd() + "/" +  relative_directory +  "/"
        elif ostype == "win":
            if relative_directory[1:3] == ":\\":
                root = relative_directory + "\\"
            else:
                root = os.getcwd() + "\\" +  relative_directory +  "\\"
    cd_list = []
    try:
        cd_list = sorted(os.listdir(root))  
    except:
        print("Could not access:", root)     
    iter_dirs = []
    for i in cd_list:
        path = root + i
        if os.path.isdir(path):
            if ls_bol:
                ls_data[path] = "".join(sorted(os.listdir(path)))
            iter_dirs.append(root + i + osep)
        else:
            data.append(path)
    for i in iter_dirs:
        iterate_dirs(root=i, data=data)

def compare_cmp(data, strict=False):
    """Compares all the file paths in a list and returns a lists of all same files"""
    similar_files_list = []
    checked = []
    for i in data:
        if i in checked:
            pass
        else:
            similar_files = []
            similar_files.append(i)
            for o in data:
                print("PROGRESS: " + str(len(checked)) + " of " + str(len(dir_data))+ "  TIME: "+ str(int(time.time()) - cepoch) +"s", end="\r")
                try:
                    if i == o or o in checked:
                        pass
                    elif strict==False:
                        iex = (i + ".")[-9:].split(".")[1]
                        oex = (o + ".")[-9:].split(".")[1]
                        if iex == oex and filecmp.cmp(i, o):
                            similar_files.append(o)
                            checked.append(o)
                        else:
                            pass # Pass if extensions dont match.
                    elif filecmp.cmp(i, o):
                        similar_files.append(o)
                        checked.append(o)
                except:
                    print("Error reading:", i)
            if len(similar_files) > 1: similar_files_list.append(similar_files)
        checked.append(i)
    return similar_files_list

def return_common_lists(l):
    global tot_red_size
    """Returns all list items inside another list after separating them with a semicolon ';'. """
    for i in l:
        print("")
        print(*i, sep=';', end="")
        sin_red_size = (os.path.getsize(i[0])*(len(i)-1)/10e5)
        tot_red_size += sin_red_size
        print(" Size:", sin_red_size, " Mega Bytes")
    return l

def check_same_dir(lis=ls_data):
    """INCOMPLETE & USELESS"""
    simdir = []
    klist = list(lis.keys())
    for i in klist:
        simidir = [i]
        for j in klist:
            if i != j and ls_data[i] == ls_data[j]:
                simidir.append(j)
                klist.remove(j)
        simdir.append(simidir)        
        klist.remove(i)
    print(simdir)

def scary_function(l):
    """Accepts a nested list containing file paths 
    [["pathtofile1", "anotherpathtofile1, "yaptf1"], ["ptf2","aptf2"]]
    where only ptf[n] are kept rest deleted
    """
    for i in l:
        for j in i:
            if j != i[0]:
               pass
               os.remove(j)
                
def usage():
    print(f"Duplic Version {VERSION}\n")
    print("Usage: duplic [OPTION]... [DIRECTORY]")
    print("""
-m  --method <compare:icmp>  method to use sha or compare
-h  --help                  display this help and exit
--version                   output version information and exit

METHODS
cmp: Uses the python filecmp module to compare duplicate files.
icmp: Same as cmp but only compares files with same file extensions.
""")


if __name__ == "__main__":
    method = "x"
    for o, a in opts:
        if o == "--version":
            print("Duplic Version {}".format(VERSION))
            sys.exit()
        elif o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-m", "--method"):
            arg = a[0].lower()
            if arg in ["i", "c", "d"]:
                method = arg
        else:
            assert False, "unhandled option"
    if method == "x":
        method = "c"
    try:
        relative_directory = args[0]
    except IndexError:
        print("Bad directory name provided.\nExiting...")
        sys.exit(1)
    dir_data = [] #Will contain a list of all file paths
    print("Populating directories list...")
    iterate_dirs(data=dir_data)
    print("Found {} files".format(len(dir_data)))
    print("Looking for duplicate files...")
    if method == "c":
        print("Using cmp")
        print("Scary function RUNNING")
        return_common_lists(compare_cmp(dir_data, True))
    elif method == "i":
        print("Using icmp")
        return_common_lists(compare_cmp(dir_data, False))
    elif method == "d":
        scary_function(return_common_lists(compare_cmp(dir_data, True)))
    print("Total Redundant size: ", tot_red_size, " Mega Bytes")
